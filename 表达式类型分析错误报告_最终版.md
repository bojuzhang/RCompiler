# 表达式类型分析错误报告 - 最终修正版

## 执行摘要

本报告基于对编译器类型检查系统的深入分析，重新审视了 `InferExpressionType` 函数的完整性问题。通过仔细分析 `parser.cpp` 中的实际表达式实现、`typecheck.cpp` 中的类型推断逻辑，以及递归类型推断的复杂情况，发现了比初步分析更精确的问题和解决方案。

## 1. 实际表达式类型分析

### 1.1 基于 parser.cpp 的准确统计

通过分析 `parser.cpp`，发现实际实现了 **23 种**表达式类型：

```cpp
// 实际实现的 23 种表达式类型
1. LiteralExpression          // 字面量表达式
2. BinaryExpression          // 二元运算表达式  
3. UnaryExpression           // 一元运算表达式
4. GroupedExpression         // 分组表达式 (expr)
5. CallExpression            // 函数调用表达式
6. MethodCallExpression      // 方法调用表达式 (注释掉)
7. IndexExpression           // 索引表达式 arr[i]
8. FieldExpression           // 字段访问表达式 obj.field
9. PathExpression            // 路径表达式 (变量、常量等)
10. ArrayExpression          // 数组表达式 [1,2,3] 或 [value; n]
11. TupleExpression          // 元组表达式 (注释掉)
12. StructExpression         // 结构体表达式 Struct { field: value }
13. EnumExpression           // 枚举表达式
14. IfExpression             // if 表达式
15. MatchExpression          // match 表达式 (注释掉)
16. BlockExpression          // 块表达式 { statements }
17. ReturnExpression         // return 表达式
18. BreakExpression          // break 表达式
19. ContinueExpression       // continue 表达式
20. AssignmentExpression     // 赋值表达式 =
21. CompoundAssignmentExpression // 复合赋值表达式 +=, -=, *=, /=
22. InfiniteLoopExpression   // 无限循环表达式 loop { }
23. PredicateLoopExpression  // 谓词循环表达式 while, for
24. UnderscoreExpression     // 下划线表达式 (注释掉)
25. ConstBlockExpression     // const 块表达式
```

**重要发现**：其中 4 种表达式类型被注释掉（MethodCallExpression、TupleExpression、MatchExpression、UnderscoreExpression），实际需要处理的为 **21 种**表达式类型。

### 1.2 InferExpressionType 当前支持情况

当前的 `InferExpressionType` 函数只能处理 6 种表达式类型：

```cpp
std::shared_ptr<SemanticType> TypeChecker::InferExpressionType(Expression& expr) {
    // 只能处理 6 种表达式类型
    if (auto literal = dynamic_cast<LiteralExpression*>(&expr)) {
        type = InferLiteralExpressionType(*literal);
    } else if (auto binary = dynamic_cast<BinaryExpression*>(&expr)) {
        type = InferBinaryExpressionType(*binary);
    } else if (auto call = dynamic_cast<CallExpression*>(&expr)) {
        type = InferCallExpressionType(*call);
    } else if (auto arrayExpr = dynamic_cast<ArrayExpression*>(&expr)) {
        type = InferArrayExpressionType(*arrayExpr);
    } else if (auto indexExpr = dynamic_cast<IndexExpression*>(&expr)) {
        type = InferIndexExpressionType(*indexExpr);
    } else if (auto pathExpr = dynamic_cast<PathExpression*>(&expr)) {
        // 路径表达式的简单处理
    }
    // 缺失 15 种表达式类型的处理
}
```

**缺失的 15 种表达式类型**：
1. UnaryExpression - 一元运算表达式
2. GroupedExpression - 分组表达式
3. FieldExpression - 字段访问表达式
4. StructExpression - 结构体表达式
5. EnumExpression - 枚举表达式
6. IfExpression - if 表达式
7. BlockExpression - 块表达式
8. ReturnExpression - return 表达式
9. BreakExpression - break 表达式
10. ContinueExpression - continue 表达式
11. AssignmentExpression - 赋值表达式
12. CompoundAssignmentExpression - 复合赋值表达式
13. InfiniteLoopExpression - 无限循环表达式
14. PredicateLoopExpression - 谓词循环表达式
15. ConstBlockExpression - const 块表达式

## 2. visit 方法中的类型推断逻辑分析

### 2.1 真正进行类型推断的 visit 方法

通过深入分析，发现以下 visit 方法确实在进行类型推断：

#### 2.1.1 BlockExpression::visit (行 1936-1988)
```cpp
void TypeChecker::visit(BlockExpression& node) {
    // 真正的类型推断逻辑
    if (node.expressionwithoutblock) {
        auto tailExprType = InferExpressionType(*node.expressionwithoutblock);
        if (tailExprType) {
            nodeTypeMap[&node] = tailExprType;  // 设置块表达式类型
        }
    } else if (!node.statements.empty()) {
        auto lastStmt = node.statements.back();
        if (auto exprStmt = dynamic_cast<ExpressionStatement*>(lastStmt.get())) {
            if (!exprStmt->hassemi && exprStmt->astnode) {
                auto lastExprType = InferExpressionType(*exprStmt->astnode);
                if (lastExprType) {
                    nodeTypeMap[&node] = lastExprType;  // 设置块表达式类型
                }
            }
        }
    }
}
```
**分析**：这是真正的类型推断，按照 Rust 语义规则确定块表达式的类型。

#### 2.1.2 IndexExpression::visit (行 1545-1585)
```cpp
void TypeChecker::visit(IndexExpression& node) {
    // 推断索引表达式的类型
    if (node.expressionout) {
        auto arrayType = InferExpressionType(*node.expressionout);
        if (arrayType) {
            if (auto arrayTypeWrapper = dynamic_cast<ArrayTypeWrapper*>(arrayType.get())) {
                auto elementType = arrayTypeWrapper->GetElementType();
                nodeTypeMap[&node] = elementType;  // 设置索引表达式类型
            }
        }
    }
}
```
**分析**：真正的类型推断，确定数组索引操作的返回类型。

#### 2.1.3 IfExpression::visit (行 1991-2027)
```cpp
void TypeChecker::visit(IfExpression& node) {
    // 检查两个分支的类型兼容性
    if (node.elseexpression) {
        auto ifType = InferExpressionType(*node.ifblockexpression);
        auto elseType = InferExpressionType(*node.elseexpression);
        if (ifType && elseType) {
            // 类型兼容性检查，但不设置 IfExpression 本身的类型
        }
    }
}
```
**分析**：进行类型兼容性检查，但没有设置 IfExpression 的类型到 nodeTypeMap。

### 2.2 主要进行语法检查的 visit 方法

以下 visit 方法主要进行语法检查，而非类型推断：

#### 2.2.1 AssignmentExpression::visit (行 1519-1528)
```cpp
void TypeChecker::visit(AssignmentExpression& node) {
    // 只检查左值的可变性，不进行类型推断
    if (node.leftexpression) {
        CheckAssignmentMutability(*node.leftexpression);
    }
}
```
**分析**：只进行可变性检查，不推断赋值表达式的类型。

#### 2.2.2 CompoundAssignmentExpression::visit (行 1530-1543)
```cpp
void TypeChecker::visit(CompoundAssignmentExpression& node) {
    // 检查可变性和右值类型，但不设置表达式类型
    if (node.leftexpression) {
        CheckAssignmentMutability(*node.leftexpression);
    }
    if (node.rightexpression) {
        auto rightType = InferExpressionType(*node.rightexpression);  // 只为检查
    }
}
```
**分析**：只为类型检查而推断右值类型，不设置复合赋值表达式的类型。

#### 2.2.3 ReturnExpression::visit (行 2030-2095)
```cpp
void TypeChecker::visit(ReturnExpression& node) {
    // 检查返回表达式与函数返回类型的兼容性
    if (node.expression) {
        auto exprType = InferExpressionType(*node.expression);
        // 进行类型兼容性检查，但不设置 ReturnExpression 的类型
    }
}
```
**分析**：只进行类型兼容性检查，不推断 return 表达式本身的类型。

## 3. 返回 SemanticType 的函数效用分析

### 3.1 核心类型推断函数

#### 3.1.1 InferExpressionType 系列
- **InferExpressionType** - 主入口，处理 6 种表达式类型
- **InferBinaryExpressionType** - 二元运算表达式类型推断
- **InferCallExpressionType** - 函数调用类型推断
- **InferIndexExpressionType** - 数组索引类型推断
- **InferLiteralExpressionType** - 字面量类型推断
- **InferArrayExpressionType** - 数组表达式类型推断

#### 3.1.2 专用类型推断函数
- **InferConstantExpressionType** - 带期望类型的常量表达式推断
- **InferArrayExpressionTypeWithExpected** - 带期望类型的数组推断
- **InferMethodCallType** - 方法调用类型推断
- **InferMethodCallExpressionType** - 方法调用表达式类型推断（未实现）

### 3.2 类型检查和解析函数

#### 3.2.1 CheckType 系列
- **CheckType(Type&)** - 类型节点检查的统一入口
- **CheckType(TypePath&)** - 路径类型检查
- **CheckType(ArrayType&)** - 数组类型检查
- **CheckType(ReferenceType&)** - 引用类型检查

#### 3.2.2 类型解析和操作函数
- **ResolveType** - 类型名称解析
- **GetBinaryOperationResultType** - 二元运算结果类型推断
- **GetImplTargetType** - impl 目标类型获取

### 3.3 辅助类型函数
- **GetBuiltinMethodReturnType** - 内置方法返回类型
- **GetExpectedType** - 获取期望类型

## 4. 递归类型推断的复杂情况分析

### 4.1 循环依赖检测机制

系统使用 `nodeTypeMap` 和占位符机制来处理循环依赖：

#### 4.1.1 通用表达式循环检测 (InferExpressionType)
```cpp
// 检查缓存
auto nodeIt = nodeTypeMap.find(&expr);
if (nodeIt != nodeTypeMap.end()) {
    // 如果缓存结果是占位符，说明正在处理中
    if (nodeIt->second->tostring() == "inferring") {
        nodeTypeMap.erase(&expr);  // 移除占位符，继续推断
    } else {
        return nodeIt->second;     // 返回已完成的推断结果
    }
}

// 防止无限递归，先设置占位符
auto placeholder = std::make_shared<SimpleType>("inferring");
nodeTypeMap[&expr] = placeholder;
```

#### 4.1.2 数组表达式循环检测
```cpp
// 使用专门的占位符 "array_expr_placeholder"
auto placeholder = std::make_shared<SimpleType>("array_expr_placeholder");
nodeTypeMap[&expr] = placeholder;
```

#### 4.1.3 常量表达式循环检测
```cpp
// 使用专门的占位符 "const_expr_placeholder"
auto placeholder = std::make_shared<SimpleType>("const_expr_placeholder");
nodeTypeMap[&expr] = placeholder;
```

### 4.2 多维数组的递归推断

多维数组推断涉及复杂的递归逻辑：

```cpp
std::shared_ptr<SemanticType> TypeChecker::InferArrayExpressionTypeWithExpected(
    ArrayExpression& expr, std::shared_ptr<SemanticType> expectedType) {
    
    // 检查是否是内层数组（多维数组的情况）
    if (auto innerArrayType = dynamic_cast<ArrayTypeWrapper*>(expectedElementType.get())) {
        // 对于多维数组的内层数组，递归处理
        if (auto innerArrayExpr = dynamic_cast<ArrayExpression*>(element.get())) {
            if (expectedElementType) {
                elemType = InferArrayExpressionTypeWithExpected(*innerArrayExpr, expectedElementType);
            }
        }
    }
}
```

### 4.3 期望类型驱动的推断

系统支持期望类型驱动的推断，特别是在常量和数组初始化中：

```cpp
std::shared_ptr<SemanticType> TypeChecker::InferConstantExpressionType(
    Expression& expr, std::shared_ptr<SemanticType> expectedType) {
    
    if (auto literalExpr = dynamic_cast<LiteralExpression*>(&expr)) {
        result = InferLiteralExpressionType(*literalExpr);
        // 如果有期望类型，检查是否可以应用隐式类型转换
        if (expectedType && result && AreTypesCompatible(expectedType, result)) {
            if (result->tostring() != expectedType->tostring()) {
                result = expectedType;  // 应用隐式转换
            }
        }
    }
}
```

## 5. 统一的 InferExpressionType 整合方案

### 5.1 设计原则

1. **完整性**：支持所有 21 种实际实现的表达式类型
2. **一致性**：使用统一的缓存和循环检测机制
3. **可扩展性**：支持期望类型驱动的推断
4. **递归安全**：防止无限递归和循环依赖

### 5.2 统一接口设计

```cpp
// 主接口 - 支持期望类型
std::shared_ptr<SemanticType> InferExpressionType(
    Expression& expr, 
    std::shared_ptr<SemanticType> expectedType = nullptr
);

// 便利接口 - 向后兼容
std::shared_ptr<SemanticType> InferExpressionType(Expression& expr) {
    return InferExpressionType(expr, nullptr);
}
```

### 5.3 完整实现方案

```cpp
std::shared_ptr<SemanticType> TypeChecker::InferExpressionType(
    Expression& expr, 
    std::shared_ptr<SemanticType> expectedType) {
    
    // 统一的循环检测和缓存机制
    auto nodeIt = nodeTypeMap.find(&expr);
    if (nodeIt != nodeTypeMap.end()) {
        if (IsPlaceholderType(nodeIt->second)) {
            if (expectedType) {
                return expectedType;  // 对于循环依赖，返回期望类型
            }
            nodeTypeMap.erase(&expr);
        } else {
            return nodeIt->second;
        }
    }
    
    // 设置占位符
    auto placeholder = CreatePlaceholder("inferring");
    nodeTypeMap[&expr] = placeholder;
    
    std::shared_ptr<SemanticType> type = nullptr;
    
    // 处理所有 21 种表达式类型
    if (auto literal = dynamic_cast<LiteralExpression*>(&expr)) {
        type = InferLiteralExpressionType(*literal);
    } else if (auto binary = dynamic_cast<BinaryExpression*>(&expr)) {
        type = InferBinaryExpressionType(*binary);
    } else if (auto call = dynamic_cast<CallExpression*>(&expr)) {
        type = InferCallExpressionType(*call);
    } else if (auto arrayExpr = dynamic_cast<ArrayExpression*>(&expr)) {
        type = expectedType ? 
            InferArrayExpressionTypeWithExpected(*arrayExpr, expectedType) :
            InferArrayExpressionType(*arrayExpr);
    } else if (auto indexExpr = dynamic_cast<IndexExpression*>(&expr)) {
        type = InferIndexExpressionType(*indexExpr);
    } else if (auto pathExpr = dynamic_cast<PathExpression*>(&expr)) {
        type = InferPathExpressionType(*pathExpr);
    } else if (auto unary = dynamic_cast<UnaryExpression*>(&expr)) {
        type = InferUnaryExpressionType(*unary);
    } else if (auto grouped = dynamic_cast<GroupedExpression*>(&expr)) {
        type = InferGroupedExpressionType(*grouped, expectedType);
    } else if (auto field = dynamic_cast<FieldExpression*>(&expr)) {
        type = InferFieldExpressionType(*field);
    } else if (auto structExpr = dynamic_cast<StructExpression*>(&expr)) {
        type = InferStructExpressionType(*structExpr);
    } else if (auto enumExpr = dynamic_cast<EnumExpression*>(&expr)) {
        type = InferEnumExpressionType(*enumExpr);
    } else if (auto ifExpr = dynamic_cast<IfExpression*>(&expr)) {
        type = InferIfExpressionType(*ifExpr);
    } else if (auto block = dynamic_cast<BlockExpression*>(&expr)) {
        type = InferBlockExpressionType(*block);
    } else if (auto returnExpr = dynamic_cast<ReturnExpression*>(&expr)) {
        type = InferReturnExpressionType(*returnExpr);
    } else if (auto breakExpr = dynamic_cast<BreakExpression*>(&expr)) {
        type = InferBreakExpressionType(*breakExpr);
    } else if (auto continueExpr = dynamic_cast<ContinueExpression*>(&expr)) {
        type = InferContinueExpressionType(*continueExpr);
    } else if (auto assign = dynamic_cast<AssignmentExpression*>(&expr)) {
        type = InferAssignmentExpressionType(*assign);
    } else if (auto compoundAssign = dynamic_cast<CompoundAssignmentExpression*>(&expr)) {
        type = InferCompoundAssignmentExpressionType(*compoundAssign);
    } else if (auto loop = dynamic_cast<InfiniteLoopExpression*>(&expr)) {
        type = InferInfiniteLoopExpressionType(*loop);
    } else if (auto predLoop = dynamic_cast<PredicateLoopExpression*>(&expr)) {
        type = InferPredicateLoopExpressionType(*predLoop);
    } else if (auto constBlock = dynamic_cast<ConstBlockExpression*>(&expr)) {
        type = InferConstBlockExpressionType(*constBlock);
    }
    
    // 应用期望类型的隐式转换
    if (type && expectedType && AreTypesCompatible(expectedType, type)) {
        if (type->tostring() != expectedType->tostring()) {
            type = expectedType;
        }
    }
    
    // 更新缓存
    if (type) {
        nodeTypeMap[&expr] = type;
    } else {
        nodeTypeMap.erase(&expr);
    }
    
    return type;
}
```

### 5.4 需要新增的推断函数

#### 5.4.1 控制流表达式类型推断
```cpp
std::shared_ptr<SemanticType> TypeChecker::InferIfExpressionType(IfExpression& expr) {
    auto ifType = InferExpressionType(*expr.ifblockexpression);
    
    if (expr.elseexpression) {
        auto elseType = InferExpressionType(*expr.elseexpression);
        if (ifType && elseType) {
            // 处理 never 类型 (!) 的特殊情况
            if (ifType->tostring() == "!") return elseType;
            if (elseType->tostring() == "!") return ifType;
            
            // 检查类型兼容性并返回公共类型
            if (AreTypesCompatible(ifType, elseType)) {
                return GetMoreSpecificType(ifType, elseType);
            }
        }
    }
    
    return ifType ? ifType : std::make_shared<SimpleType>("()");
}

std::shared_ptr<SemanticType> TypeChecker::InferBlockExpressionType(BlockExpression& block) {
    // 复用 visit 方法中的逻辑
    if (block.expressionwithoutblock) {
        return InferExpressionType(*block.expressionwithoutblock);
    } else if (!block.statements.empty()) {
        auto lastStmt = block.statements.back();
        if (auto exprStmt = dynamic_cast<ExpressionStatement*>(lastStmt.get())) {
            if (!exprStmt->hassemi && exprStmt->astnode) {
                return InferExpressionType(*exprStmt->astnode);
            }
        }
    }
    return std::make_shared<SimpleType>("()");
}
```

#### 5.4.2 数据结构表达式类型推断
```cpp
std::shared_ptr<SemanticType> TypeChecker::InferFieldExpressionType(FieldExpression& expr) {
    auto baseType = InferExpressionType(*expr.expression);
    if (!baseType) return nullptr;
    
    // 查找结构体字段类型
    if (auto structSymbol = FindStruct(baseType->tostring())) {
        for (const auto& field : structSymbol->fields) {
            if (field->name == expr.identifier) {
                return field->type;
            }
        }
    }
    
    ReportError("Field '" + expr.identifier + "' not found in type '" + baseType->tostring() + "'");
    return nullptr;
}

std::shared_ptr<SemanticType> TypeChecker::InferStructExpressionType(StructExpression& expr) {
    // 查找结构体定义
    auto structSymbol = FindStruct(expr.identifier);
    if (!structSymbol) {
        ReportError("Unknown struct type: " + expr.identifier);
        return nullptr;
    }
    
    // 检查字段初始化
    for (const auto& field : expr.structfields->structfields) {
        // 字段类型检查逻辑
    }
    
    return std::make_shared<SimpleType>(expr.identifier);
}
```

#### 5.4.3 内存管理表达式类型推断
```cpp
std::shared_ptr<SemanticType> TypeChecker::InferUnaryExpressionType(UnaryExpression& expr) {
    auto operandType = InferExpressionType(*expr.expression);
    if (!operandType) return nullptr;
    
    switch (expr.unarytype) {
        case Token::kMinus:
            // 一元负号，返回与操作数相同的数值类型
            if (IsNumericType(operandType)) {
                return operandType;
            }
            break;
        case Token::kNot:
            // 逻辑非，返回 bool 类型
            return std::make_shared<SimpleType>("bool");
        case Token::kAnd:
            // 引用操作，返回引用类型
            return std::make_shared<ReferenceTypeWrapper>(operandType, false);
        case Token::kMutAnd:
            // 可变引用操作
            return std::make_shared<ReferenceTypeWrapper>(operandType, true);
        case Token::kStar:
            // 解引用操作
            if (auto refType = dynamic_cast<ReferenceTypeWrapper*>(operandType.get())) {
                return refType->getTargetType();
            }
            break;
    }
    
    ReportError("Invalid unary operation for type: " + operandType->tostring());
    return nullptr;
}
```

### 5.5 重构现有代码

#### 5.5.1 统一 visit 方法使用
```cpp
void TypeChecker::visit(BlockExpression& node) {
    PushNode(node);
    
    scopeTree->EnterScope(Scope::ScopeType::Block, &node);
    for (const auto &stmt : node.statements) {
        stmt->accept(*this);
    }
    
    // 使用统一的 InferExpressionType
    auto blockType = InferExpressionType(node);
    if (blockType) {
        nodeTypeMap[&node] = blockType;
    }
    
    scopeTree->ExitScope();
    PopNode();
}
```

#### 5.5.2 简化类型检查逻辑
```cpp
void TypeChecker::visit(LetStatement& node) {
    PushNode(node);
    
    std::shared_ptr<SemanticType> declaredType = nullptr;
    if (node.type) {
        declaredType = CheckType(*node.type);
    }
    
    // 使用统一的 InferExpressionType
    if (node.expression) {
        auto initType = InferExpressionType(*node.expression, declaredType);
        if (declaredType && initType && !AreTypesCompatible(declaredType, initType)) {
            ReportError("Type mismatch in let statement: expected '" + 
                       declaredType->tostring() + "', found '" + 
                       initType->tostring() + "'");
        }
    }
    
    if (node.patternnotopalt) {
        std::shared_ptr<SemanticType> varType = declaredType ? 
            declaredType : InferExpressionType(*node.expression);
        CheckPattern(*node.patternnotopalt, varType);
    }
    
    PopNode();
}
```

## 6. 实现优先级和步骤

### 6.1 第一阶段：核心表达式类型推断
1. **UnaryExpression** - 一元运算表达式（高优先级，基础运算）
2. **GroupedExpression** - 分组表达式（简单，影响优先级）
3. **FieldExpression** - 字段访问表达式（结构体基础功能）
4. **IfExpression** - if 表达式（控制流基础）

### 6.2 第二阶段：数据结构表达式
5. **StructExpression** - 结构体表达式
6. **EnumExpression** - 枚举表达式
7. **BlockExpression** - 块表达式（已有逻辑，需要整合）

### 6.3 第三阶段：控制流表达式
8. **ReturnExpression** - return 表达式（类型检查已有）
9. **BreakExpression** - break 表达式（never 类型）
10. **ContinueExpression** - continue 表达式（never 类型）
11. **InfiniteLoopExpression** - 无限循环表达式（never 类型）
12. **PredicateLoopExpression** - 谓词循环表达式（unit 类型）

### 6.4 第四阶段：赋值和特殊表达式
13. **AssignmentExpression** - 赋值表达式（已有可变性检查）
14. **CompoundAssignmentExpression** - 复合赋值表达式
15. **ConstBlockExpression** - const 块表达式

## 7. 预期效果和改进

### 7.1 完整性提升
- **覆盖率**：从 29% (6/21) 提升到 100% (21/21)
- **一致性**：所有表达式类型推断使用统一接口
- **可维护性**：集中的类型推断逻辑，易于调试和扩展

### 7.2 性能优化
- **缓存机制**：统一的 `nodeTypeMap` 缓存，避免重复推断
- **循环检测**：防止无限递归，提高稳定性
- **期望类型驱动**：减少不必要的类型转换

### 7.3 错误处理改进
- **统一错误报告**：集中的错误处理机制
- **更好的错误信息**：包含期望类型和实际类型的详细信息
- **恢复机制**：部分推断失败时的优雅降级

## 8. 风险评估和缓解策略

### 8.1 主要风险
1. **向后兼容性**：现有代码可能依赖当前的行为
2. **性能影响**：统一的推断机制可能影响性能
3. **复杂性增加**：支持所有表达式类型增加系统复杂性

### 8.2 缓解策略
1. **渐进式实现**：按优先级分阶段实现
2. **保持向后兼容**：保留现有接口作为便利函数
3. **性能测试**：每个阶段进行性能基准测试
4. **充分测试**：为每种表达式类型编写全面的测试用例

## 9. 结论

通过深入分析，我们发现 `InferExpressionType` 函数确实存在严重的完整性问题，只能处理 21 种实际表达式类型中的 6 种。然而，大部分缺失的类型推断逻辑已经存在于 `typecheck.cpp` 的各个角落，特别是 visit 方法中。

关键发现：
1. **真正的类型推断**：BlockExpression、IndexExpression 等确实在进行类型推断
2. **语法检查为主**：AssignmentExpression、ReturnExpression 等主要进行语法检查
3. **递归安全机制**：已有完善的循环依赖检测和占位符机制
4. **期望类型支持**：已有期望类型驱动的推断基础

建议的统一整合方案将：
- 提供完整的表达式类型推断覆盖
- 保持现有的递归安全机制
- 支持期望类型驱动的推断
- 简化代码维护和调试

这个方案将显著提升编译器类型系统的完整性、一致性和可维护性，为后续的语言特性扩展奠定坚实基础。