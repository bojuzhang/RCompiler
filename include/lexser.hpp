#include <regex>
#include <utility>
#include <vector>

enum class Token {
    // tokens
    kIDENTIFIER,
    kCHAR_LITERAL,
    kSTRING_LITERAL,
    kRAW_STRING_LITERAL,
    kBYTE_LITERAL,
    kBYTE_STRING_LITERAL,
    kRAW_BYTE_STRING_LITERAL,
    kC_STRING_LITERAL,
    kRAW_C_STRING_LITERAL,
    kINTEGER_LITERAL,
    kRESERVED_TOKEN,

    // restrict keyword
    kas,
    kbreak,
    kconst,
    kcontinue,
    kcrate,
    kelse,
    kenum,
    kfalse,
    kfn,
    kfor,
    kif,
    kimpl,
    kin,
    klet,
    kloop,
    kmatch,
    kmod,
    kmove,
    kmut,
    kref,
    kreturn,
    kself,
    kSelf,
    kstatic,
    kstruct,
    ksuper,
    ktrait,
    ktrue,
    ktype,
    kunsafe,
    kuse,
    kwhere,
    kwhile,
    kdyn,

    // punctuation
    kPlus,
    kMinus,
    kStar,
    kSlash,
    kPercent,
    kCaret,
    kNot,
    kAnd,
    kOr,
    kAndAnd,
    kOrOr,
    kShl,
    kShr,
    kPlusEq,
    kMinusEq,
    kStarEq,
    kSlashEq,
    kPercentEq,
    kCaretEq,
    kAndEq,
    kOrEq,
    kShlEq,
    kShrEq,
    kEq,
    kEqEq,
    kNe,
    kGt,
    kLt,
    kGe,
    kLe,
    kAt,
    kUnderscore,
    kDot,
    kDotDot,
    kDotDotDot,
    kDotDotEq,
    kComma,
    kSemi,
    kColon,
    kPathSep,
    kRArrow,
    kFatArrow,
    kLArrow,
    kPound,
    kDollar,
    kQuestion,
    kTilde,

    // delimeters
    kleftCurly,
    krightCurly,
    kleftSquare,
    kRightSquare,
    kleftParenthe,
    krightParenthe,

    kCOMMENT,
};

class lexser {
private:
    std::vector<std::pair<Token, std::regex>> patterns = {
        {Token::kas, std::regex("as")},
        {Token::kbreak, std::regex("break")},
        {Token::kconst, std::regex("const")},
        {Token::kcontinue, std::regex("continue")},
        {Token::kcrate, std::regex("crate")},
        {Token::kelse, std::regex("else")},
        {Token::kenum, std::regex("enum")},
        // {Token::kextern, std::regex("extern")},
        {Token::kfalse, std::regex("false")},
        {Token::kfn, std::regex("fn")},
        {Token::kfor, std::regex("for")},
        {Token::kif, std::regex("if")},
        {Token::kimpl, std::regex("impl")},
        {Token::kin, std::regex("in")},
        {Token::klet, std::regex("let")},
        {Token::kloop, std::regex("loop")},
        {Token::kmatch, std::regex("match")},
        {Token::kmod, std::regex("mod")},
        {Token::kmove, std::regex("move")},
        {Token::kmut, std::regex("mut")},
        // {Token::kpub, std::regex("pub")},
        {Token::kref, std::regex("ref")},
        {Token::kreturn, std::regex("return")},
        {Token::kself, std::regex("self")},
        {Token::kSelf, std::regex("Self")},
        {Token::kstatic, std::regex("static")},
        {Token::kstruct, std::regex("struct")},
        {Token::ksuper, std::regex("super")},
        {Token::ktrait, std::regex("trait")},
        {Token::ktrue, std::regex("true")},
        {Token::ktype, std::regex("type")},
        {Token::kunsafe, std::regex("unsafe")},
        {Token::kuse, std::regex("use")},
        {Token::kwhere, std::regex("where")},
        {Token::kwhile, std::regex("while")},
        // {Token::kasync, std::regex("async")},
        // {Token::kawait, std::regex("await")},
        {Token::kdyn, std::regex("dyn")},

        // {Token::kabstract, std::regex("abstract")},
        // {Token::kbecome, std::regex("become")},
        // {Token::kbox, std::regex("box")},
        // {Token::kdo, std::regex("do")},
        // {Token::kfinal, std::regex("final")},
        // {Token::kmacro, std::regex("macro")},
        // {Token::koverride, std::regex("override")},
        // {Token::kpriv, std::regex("priv")},
        // {Token::ktypeof, std::regex("typeof")},
        // {Token::kunsized, std::regex("unsized")},
        // {Token::kvirtual, std::regex("virtual")},
        // {Token::kyield, std::regex("yield")},
        // {Token::ktry, std::regex("try")},
        // {Token::kgen, std::regex("gen")},

        {Token::kIDENTIFIER, std::regex("[a-zA-Z][a-zA-Z0-9_]*")},
        {Token::kCHAR_LITERAL, std::regex(R"('([^'\\\n\r\t])|(\\'\\")|(0x[0-7][0-9a-fA-F]|\n|\r|\t|\\\\|\0)'([a-zA-Z][a-zA-Z0-9_]*)?)")},
        {Token::kSTRING_LITERAL, std::regex(R"delimiter("(([^"\\\r\t])|(\\'\\")|(0x[0-7][0-9a-fA-F]|\n|\r|\t|\\\\|\0)|(\\\n))*"([a-zA-Z][a-zA-Z0-9_]*)?)delimiter")},
        {Token::kRAW_STRING_LITERAL, std::regex(R"(r([#]+)([^\r])*?(\1))")},
        {Token::kBYTE_LITERAL, std::regex(R"(b'(([^'\\\r\t\n])|(0x[0-7][0-9a-fA-F]|\n|\r|\t|\\\\|\0)|(\\\n)|(\\')|(\\"))'([a-zA-Z][a-zA-Z0-9_]*)?)")},
        {Token::kBYTE_STRING_LITERAL, std::regex(R"delimeter(b"(([^"\\\r])|(0x[0-7][0-9a-fA-F]|\n|\r|\t|\\\\|\0)|((\\\n)|(\\')|(\\")|(\\\n)))*"([a-zA-Z][a-zA-Z0-9_]*)?)delimeter")},
        {Token::kRAW_BYTE_STRING_LITERAL, std::regex(R"(br([#]+)([^\r])*?(\1))")},
        {Token::kC_STRING_LITERAL, std::regex(R"(c"(([^"\\\r\0])|(0x[0-7][0-9a-fA-F]|\n|\r|\t|\\\\)|(\\\n))*")")},
        {Token::kRAW_C_STRING_LITERAL, std::regex(R"(cr([#]+)([^\r\0])*?(\1))")},
        {Token::kINTEGER_LITERAL, std::regex("(([0-9][0-9_]*)|(0b[0-1_]*[0-1][0-1_]*)|(0o[0-7_]*[0-7][0-7_]*)|(0x[0-9a-fA-F_]*[0-9a-fA-F][0-9a-fA-F_]*))([a-df-zA-DF-Z][a-zA-Z0-9_]*)?")},
        // {Token::kFLOAT_LITERAL, std::regex("(([0-9][0-9_]*).(?![._a-zA-Z]))|(([0-9][0-9_]*).([0-9][0-9_]*)([a-df-zA-DF-Z][a-zA-Z0-9_]*)?)")},
        // {Token::kPUNCTUATION, std::regex()}, 
        {Token::kRESERVED_TOKEN, std::regex(R"delimiter((#+"(([^'\\\r\t])|(\\'\\")|(0x[0-7][0-9a-fA-F]|\n|\r|\t|\\\\|\0)|(\\\n))*"([a-zA-Z][a-zA-Z0-9_]*)?)|((0b[0-1_]*[0-1][0-1_]*[2-9])|(0o[0-7_]*[0-7][0-7_]*[8-9])|((0b[0-1_]*[0-1][0-1_]*)|(0o[0-7_]*[0-7][0-7_]*)|(0x[0-9a-fA-F_]*[0-9a-fA-F][0-9a-fA-F_]*).(?![._a-zA-Z]))|))delimiter")},

        {Token::kPlus, std::regex(R"(\+)")},
        {Token::kMinus, std::regex("-")},
        {Token::kStar, std::regex(R"(\*)")},
        {Token::kSlash, std::regex("/")},
        {Token::kPercent, std::regex("%")},
        {Token::kCaret, std::regex(R"(\^)")},
        {Token::kNot, std::regex(R"(\!)")},
        {Token::kAnd, std::regex("&")},
        {Token::kOr, std::regex(R"(\|)")},
        {Token::kAndAnd, std::regex("&&")},
        {Token::kOrOr, std::regex(R"(\|\|)")},
        {Token::kShl, std::regex("<<")},
        {Token::kShr, std::regex(">>")},
        {Token::kPlusEq, std::regex(R"(\+=)")},
        {Token::kMinusEq, std::regex("-=")},
        {Token::kStarEq, std::regex(R"(\*=)")},
        {Token::kSlashEq, std::regex("/=")},
        {Token::kPercentEq, std::regex("%=")},
        {Token::kCaretEq, std::regex(R"(\^=)")},
        {Token::kAndEq, std::regex("&=")},
        {Token::kOrEq, std::regex(R"(\|=)")},
        {Token::kShlEq, std::regex("<<=")},
        {Token::kShrEq, std::regex(">>=")},
        {Token::kEq, std::regex("=")},
        {Token::kEqEq, std::regex("==")},
        {Token::kNe, std::regex(R"(\!=)")},
        {Token::kGt, std::regex(">")},
        {Token::kLt, std::regex("<")},
        {Token::kGe, std::regex(">=")},
        {Token::kLe, std::regex("<=")},
        {Token::kAt, std::regex("@")},
        {Token::kUnderscore, std::regex("_")},
        {Token::kDot, std::regex(R"(\.)")},
        {Token::kDotDot, std::regex(R"(\.\.)")},
        {Token::kDotDotDot, std::regex(R"(\.\.\.)")},
        {Token::kDotDotEq, std::regex(R"(\.\.=)")},
        {Token::kComma, std::regex(",")},
        {Token::kSemi, std::regex(";")},
        {Token::kColon, std::regex(":")},
        {Token::kPathSep, std::regex("::")},
        {Token::kRArrow, std::regex("->")},
        {Token::kFatArrow, std::regex("=>")},
        {Token::kLArrow, std::regex("<-")},
        {Token::kPound, std::regex("#")},
        {Token::kDollar, std::regex(R"(\$)")},
        {Token::kQuestion, std::regex(R"(\?)")},
        {Token::kTilde, std::regex("~")},

        {Token::kleftCurly, std::regex(R"(\{)")},
        {Token::krightCurly, std::regex(R"(\})")},
        {Token::kleftSquare, std::regex(R"(\[)")},
        {Token::kRightSquare, std::regex(R"(\])")},
        {Token::kleftParenthe, std::regex(R"(\()")},
        {Token::krightParenthe, std::regex(R"(\))")},

        {Token::kCOMMENT, std::regex(R"((//.*\n)|(/\*[\s\S]*\*/))")},
    };

public:
    std::vector<std::pair<Token, std::string>> lexString(std::string); 

    std::string getString();
};
