Builtin functions
Builtin functions operate on standard input (stdin) and standard output (stdout) unless otherwise stated.

print
fn print(s: &str) -> ()
Writes the exact bytes of s to stdout without appending a newline.

print("Hello, world!");
println
fn println(s: &str) -> ()
Writes the exact bytes of s to stdout and then writes a single newline character.

println("Hello, world!");
printInt
fn printInt(n: i32) -> ()
Writes the decimal ASCII representation of n to stdout without a trailing newline.

printInt(42);
printlnInt
fn printlnInt(n: i32) -> ()
Writes the decimal ASCII representation of n to stdout and then writes a single newline character.

printlnInt(42);
getString
fn getString() -> String
Reads one line from stdin and returns it as a String. The trailing newline, if any, is not included in the returned value.

let name: String = getString();
println(name.as_str());
getInt
fn getInt() -> i32
Reads an integer token from stdin and returns it as an i32.

let a: i32 = getInt();
let b: i32 = getInt();
printlnInt(a + b);
exit
fn exit(code: i32) -> ()
Immediately terminates the current process and returns the provided exit code to the parent process. During type checking, exit is treated as returning () (this specification does not include a never type). Nevertheless, control flow does not continue after the call at runtime.

exit may appear only as the final statement of the main function. Using exit anywhere else is a semantic error.

fn main() -> () {
    println("done");
    exit(0);
}
The following is invalid:


fn main() -> () {
    exit(1);
    println("unreachable");  // compile-time error
}