# StatementGenerator 组件设计文档

## 概述

StatementGenerator 组件负责将 Rx 语言的语句转换为 LLVM IR 文本。它是 IR 生成阶段的核心组件之一，处理各种类型的语句生成，包括变量声明、赋值语句、控制流语句等。

**重要架构说明**：根据 AST 节点设计，Statement 使用组合模式，控制流语句（if、loop、while、break、continue、return）都是 Expression 的子类，BlockExpression 包含 Statement 向量。这导致 StatementGenerator 和 ExpressionGenerator 之间存在循环依赖关系，需要通过前向声明和接口分离来解决。

## 设计目标

1. **完整的语句支持**：支持所有 Rx 语言语句类型的 IR 生成
2. **循环依赖解决**：通过接口分离解决 StatementGenerator 和 ExpressionGenerator 的循环依赖
3. **控制流管理**：正确处理复杂控制流结构
4. **作用域感知**：与 ScopeTree 和 IRBuilder 的作用域管理集成
5. **错误处理**：提供完善的错误检测和恢复机制

## 核心架构

### 语句分类

根据 AST 节点结构，StatementGenerator 处理以下语句类型：

1. **Let 语句**（LetStatement）
   - 变量声明：`let x: i32 = 42`
   - 类型推断：`let y = 10`
   - 可变变量：`let mut z = 5`

2. **表达式语句**（ExpressionStatement）
   - 函数调用语句：`func(arg1, arg2)`（有分号）
   - 方法调用语句：`obj.method(arg)`（有分号）
   - 赋值表达式语句：`x = value`（有分号）

3. **项语句**（Item）
   - 函数定义：`fn name() -> type { body }`
   - 结构体定义：`struct Name { fields }`
   - 常量定义：`const NAME: type = value`

4. **复合语句**（通过 Statement 组合处理）
   - 注意：BlockExpression 现在由 ExpressionGenerator 处理，StatementGenerator 不再处理

### 循环依赖解决策略

由于以下循环依赖关系：
- `StatementGenerator` → `ExpressionGenerator`（处理表达式语句中的表达式）
- `ExpressionGenerator` → `StatementGenerator`（处理 BlockExpression 中的语句）

采用以下解决策略：

1. **前向声明**：两个组件互相前向声明
2. **接口分离**：将循环依赖的操作分离到独立接口
3. **延迟初始化**：通过构造函数后初始化解决循环引用
4. **职责明确**：
   - `StatementGenerator`：只处理真正的语句（Let、Item、ExpressionStatement）
   - `ExpressionGenerator`：处理所有表达式，包括 BlockExpression 和控制流表达式
   - `BlockExpression`：完全由 `ExpressionGenerator` 处理，通过调用 `StatementGenerator` 处理其中的语句

### 组件接口设计

1. **前向声明和延迟初始化**：
   - 前向声明 ExpressionGenerator 类以解决循环依赖
   - 使用延迟初始化模式设置 ExpressionGenerator 引用
   - 通过 setExpressionGenerator 方法建立双向引用

2. **构造函数参数**：
   - 接收 IRBuilder、TypeMapper、ScopeTree 作为核心依赖
   - 接收节点类型映射用于类型信息查询
   - 初始化组件的基本状态和控制流栈

3. **主要生成接口**：
   - `generateStatement()`: 通用的语句生成入口点
   - 根据语句类型分发到相应的生成方法
   - 处理语句生成的异常和错误

4. **专用生成方法**：
   - `generateLetStatement()`: 处理变量声明语句
   - `generateExpressionStatement()`: 处理表达式语句
   - `generateItemStatement()`: 处理项语句（函数、结构体等）

5. **工具方法**：
   - `getStatementType()`: 获取语句的类型信息
   - `isStatementTerminator()`: 检查语句是否为终止符
   - `handleUnreachableCode()`: 处理不可达代码

6. **控制流上下文管理**：
   - ControlFlowContext 结构管理循环上下文信息
   - 维护循环结束标签、break/continue 目标
   - 使用栈结构管理嵌套控制流

7. **控制流辅助方法**：
   - `enterControlFlowContext()`/`exitControlFlowContext()`: 管理控制流上下文
   - `addBreakTarget()`/`addContinueTarget()`: 添加跳转目标
   - `getCurrentBreakTarget()`/`getCurrentContinueTarget()`: 获取当前跳转目标

8. **职责边界说明**：
   - BlockExpression 完全由 ExpressionGenerator 处理
   - StatementGenerator 只提供 generateStatement 方法供调用
   - 明确组件间的职责分工

## 实现策略

### Let 语句生成

1. **变量信息提取**：
   - 从模式中提取变量名
   - 确定变量的类型信息
   - 处理显式类型和类型推断

2. **类型确定策略**：
   - 优先使用显式指定的类型
   - 从初始化表达式推断类型
   - 使用默认类型作为后备

3. **内存分配**：
   - 为变量分配栈空间
   - 生成指针寄存器用于变量访问
   - 确保寄存器命名的唯一性

4. **初始化处理**：
   - 生成初始化表达式的代码
   - 处理必要的类型转换
   - 存储初始值到分配的内存

5. **符号表注册**：
   - 创建符号信息并注册到当前作用域
   - 通过 IRBuilder 注册变量寄存器
   - 维护符号表和寄存器的同步

### 表达式语句生成

1. **依赖检查**：
   - 验证 ExpressionGenerator 是否已设置
   - 确保组件间的正确依赖关系
   - 处理未设置依赖的错误情况

2. **表达式类型识别**：
   - 检查表达式是否为控制流表达式
   - 识别各种控制流结构（if、loop、while、break、return）
   - 区分普通表达式和控制流表达式

3. **控制流表达式处理**：
   - 将控制流表达式委托给 ExpressionGenerator
   - 保持控制流生成的一致性
   - 确保 BlockExpression 的正确处理

4. **普通表达式处理**：
   - 生成表达式代码并获取结果寄存器
   - 对于有分号的表达式语句，丢弃结果
   - 添加适当的注释说明

### 项语句生成

1. **项类型识别**：
   - 使用动态类型转换识别项的具体类型
   - 支持函数、结构体、常量、impl 块等类型
   - 处理不支持的项类型

2. **项生成分发**：
   - 将函数定义委托给函数生成器
   - 将结构体定义委托给结构体生成器
   - 将常量定义委托给常量生成器
   - 将 impl 块委托给 impl 生成器

3. **错误处理**：
   - 对不支持的项类型报告错误
   - 提供详细的错误信息
   - 保持生成过程的稳定性

### 控制流语句生成

#### if 语句

1. **条件处理**：
   - 生成条件表达式的代码
   - 获取条件结果的寄存器
   - 确保条件类型的正确性

2. **基本块创建**：
   - 创建 then、else 和 end 基本块
   - 确保基本块名称的唯一性
   - 设置基本块的语义化命名

3. **条件跳转生成**：
   - 生成条件跳转指令
   - 连接条件结果和目标基本块
   - 确保跳转逻辑的正确性

4. **分支生成**：
   - 生成 then 分支的代码
   - 管理 then 块的作用域
   - 处理 BlockExpression 的委托生成

5. **分支终止检查**：
   - 检查分支是否以终止符结束
   - 为非终止分支生成跳转到结束块
   - 确保控制流的正确性

#### loop 语句

1. **基本块结构**：
   - 创建循环头和结束基本块
   - 设置循环的语义化命名
   - 建立循环的基本块框架

2. **循环上下文管理**：
   - 进入循环控制流上下文
   - 设置 break 目标标签
   - 维护循环的嵌套信息

3. **循环体生成**：
   - 生成循环体的代码
   - 管理循环体的作用域
   - 处理循环体中的语句

4. **循环控制**：
   - 生成循环体到循环头的跳转
   - 设置循环结束基本块
   - 退出循环控制流上下文

#### while 语句

1. **三块结构**：
   - 创建条件、体和结束基本块
   - 建立循环的标准三块结构
   - 设置语义化的基本块命名

2. **循环上下文**：
   - 进入 while 循环的控制流上下文
   - 设置 break 目标为循环结束
   - 维护循环的嵌套状态

3. **条件检查**：
   - 生成条件表达式的代码
   - 生成条件跳转指令
   - 连接条件和循环体

4. **循环体和跳转**：
   - 生成循环体的代码
   - 生成循环体到条件检查的跳转
   - 完成循环的控制流

### 跳转语句生成

#### break 语句

1. **目标验证**：
   - 检查是否在循环上下文中
   - 获取当前 break 目标
   - 处理 break 语句的位置错误

2. **break 值处理**：
   - 生成 break 值表达式的代码
   - 创建或获取 break 值存储位置
   - 存储 break 值到指定位置

3. **跳转生成**：
   - 生成到循环结束的跳转指令
   - 标记后续代码为不可达
   - 处理不可达代码的状态

#### continue 语句

1. **目标验证**：
   - 检查是否在循环上下文中
   - 获取当前 continue 目标
   - 处理 continue 语句的位置错误

2. **跳转生成**：
   - 生成到 continue 目标的跳转
   - 标记后续代码为不可达
   - 确保跳转目标的正确性

#### return 语句

1. **返回类型获取**：
   - 获取当前函数的返回类型
   - 验证返回语句的上下文
   - 确保返回类型的正确性

2. **返回值处理**：
   - 生成返回值表达式的代码
   - 处理返回值的类型转换
   - 确保返回值与函数类型匹配

3. **返回指令生成**：
   - 生成适当的返回指令
   - 处理有返回值和无返回值的情况
   - 标记后续代码为不可达

## 控制流上下文管理

### 上下文栈管理

1. **上下文创建**：
   - 创建新的控制流上下文结构
   - 生成循环结束标签
   - 设置循环的基本信息

2. **上下文栈操作**：
   - 将新上下文压入栈
   - 弹出当前上下文
   - 维护上下文栈的正确性

3. **跳转目标管理**：
   - 添加 break 目标到当前上下文
   - 添加 continue 目标到当前上下文
   - 维护跳转目标的列表

4. **目标获取策略**：
   - 获取当前 break 目标
   - 获取当前 continue 目标
   - 处理不同循环类型的跳转差异

### 不可达代码处理

1. **不可达基本块创建**：
   - 创建专门的不可达基本块
   - 设置当前基本块为不可达块
   - 生成 unreachable 指令

2. **状态管理**：
   - 设置不可达代码标志
   - 跳过后续代码的生成
   - 维护代码可达性状态

## 与其他组件的集成

### 与 ExpressionGenerator 的集成

1. **依赖关系**：
   - StatementGenerator 依赖 ExpressionGenerator
   - 通过延迟初始化解决循环依赖
   - 建立双向引用关系

2. **表达式处理**：
   - 使用 ExpressionGenerator 生成表达式代码
   - 处理初始化表达式中的复杂逻辑
   - 确保表达式生成的正确性

3. **控制流委托**：
   - 将控制流表达式委托给 ExpressionGenerator
   - 保持控制流生成的一致性
   - 避免重复的实现逻辑

### 与 IRBuilder 的集成

1. **基本块管理**：
   - 使用 IRBuilder 创建和管理基本块
   - 设置当前活动的基本块
   - 同步基本块状态

2. **寄存器管理**：
   - 通过 IRBuilder 分配寄存器
   - 管理变量寄存器的映射
   - 确保寄存器的正确使用

3. **作用域同步**：
   - 与 IRBuilder 同步作用域状态
   - 处理作用域的进入和退出
   - 维护作用域信息的一致性

### 与 ScopeTree 的集成

1. **职责分离**：
   - BlockExpression 完全由 ExpressionGenerator 处理
   - StatementGenerator 不再直接处理 BlockExpression
   - 通过接口调用处理 BlockExpression 中的语句

2. **作用域管理**：
   - 通过 ScopeTree 管理变量作用域
   - 处理变量的注册和查找
   - 维护作用域的层次结构

## 错误处理

### 语句错误检测

1. **错误状态管理**：
   - 维护错误发生标志
   - 收集错误信息列表
   - 提供错误查询接口

2. **错误报告**：
   - 格式化错误信息
   - 输出错误到标准错误流
   - 包含错误的详细描述

3. **控制流错误**：
   - 检测控制流语句的位置错误
   - 报告无效的控制流使用
   - 提供上下文信息

### 错误恢复策略

1. **异常捕获**：
   - 捕获语句生成过程中的异常
   - 记录详细的错误信息
   - 防止错误传播

2. **恢复代码生成**：
   - 根据语句类型生成恢复代码
   - 为 let 语句生成默认初始化
   - 跳过有问题的表达式语句

3. **继续处理**：
   - 在错误发生后继续处理其他语句
   - 最大化生成有效代码
   - 提供完整的错误报告

## 性能优化

### 死代码消除

1. **不可达代码检测**：
   - 维护不可达代码标志
   - 跳过不可达代码的生成
   - 添加适当的注释说明

2. **标志管理**：
   - 在遇到跳转语句时设置标志
   - 在生成后续语句时检查标志
   - 重置标志以恢复正常生成

### 基本块合并

1. **合并条件检查**：
   - 检查相邻基本块是否可以合并
   - 分析基本块间的跳转关系
   - 执行基本块合并操作

2. **优化效果**：
   - 减少基本块数量
   - 简化控制流图
   - 提高生成代码的效率

## 测试策略

### 单元测试

1. **Let 语句测试**：
   - 测试变量声明的正确生成
   - 验证 alloca 和 store 指令
   - 检查类型推断和转换

2. **控制流测试**：
   - 测试 if 语句的基本块生成
   - 验证条件跳转的正确性
   - 检查分支和结束块

3. **循环测试**：
   - 测试 loop 和 while 语句
   - 验证循环结构的正确性
   - 检查 break 和 continue 处理

### 集成测试

1. **复杂控制流测试**：
   - 测试嵌套的控制流结构
   - 验证复杂场景的正确性
   - 检查控制流的完整性

2. **错误处理测试**：
   - 测试错误情况的正确处理
   - 验证错误恢复机制
   - 检查错误报告的完整性

## 使用示例

### 基本使用

1. **组件初始化**：
   - 创建所有依赖组件
   - 设置组件间的引用关系
   - 初始化 StatementGenerator

2. **简单语句生成**：
   - 生成 let 语句的 IR 代码
   - 生成 if 语句的控制流
   - 验证生成结果的正确性

3. **输出验证**：
   - 检查生成的 IR 指令
   - 验证寄存器和基本块
   - 确保语法的正确性

### 高级使用

1. **复杂控制流**：
   - 生成嵌套循环结构
   - 处理循环中的条件分支
   - 管理 break 和 continue 语句

2. **错误处理**：
   - 处理生成过程中的错误
   - 生成错误恢复代码
   - 提供详细的错误信息

3. **性能优化**：
   - 应用死代码消除
   - 执行基本块合并
   - 优化生成代码的效率

## 总结

StatementGenerator 组件是 IR 生成阶段的核心组件，提供了完整的语句生成功能：

1. **完整的语句支持**：支持所有 Rx 语言语句类型的 IR 生成
2. **与 ExpressionGenerator 协作**：无缝集成表达式生成，共享寄存器管理
3. **职责明确**：只处理真正的语句（Let、Item、ExpressionStatement），不处理 BlockExpression
4. **控制流管理**：正确处理复杂嵌套控制流结构
5. **作用域感知**：与 ScopeTree 和 IRBuilder 完全集成
6. **错误处理**：完善的错误检测和恢复机制
7. **性能优化**：死代码消除、基本块合并等优化
8. **易于扩展**：清晰的接口设计，便于添加新的语句类型

通过 StatementGenerator，IR 生成器可以将复杂的 Rx 语言语句正确地转换为高效的 LLVM IR 代码，并与 ExpressionGenerator、IRBuilder、TypeMapper 等组件形成完整的代码生成流水线。