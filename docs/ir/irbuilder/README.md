# IRBuilder 组件设计文档

## 概述

IRBuilder 是 Rx 语言编译器 IR 生成模块的核心组件，负责生成符合 LLVM 15 语法的 IR 文本。IRBuilder 完全不依赖 LLVM C++ API，而是通过自定义的指令生成系统直接输出 LLVM IR 文本到 stdout。

## 设计目标

1. **完全独立**：不依赖任何 LLVM C++ API 或 IRBuilder
2. **直接输出**：生成 LLVM IR 文本并直接输出到 stdout
3. **类型安全**：确保生成的 IR 符合 LLVM 类型系统
4. **寄存器管理**：自动管理寄存器分配和命名
5. **基本块管理**：支持复杂控制流的基本块管理

## 核心架构

### 寄存器管理系统

IRBuilder 维护一个复杂的寄存器命名和作用域管理系统：

- **临时寄存器**：`_1`, `_2`, `_3`, ...
- **作用域感知的命名寄存器**：`var1_1`, `var1_2`, ...（处理变量遮蔽）
- **类型区分寄存器**：`var1_ptr`, `var1_val`, `var1_addr`（区分指针和值）
- **寄存器类型跟踪**：每个寄存器都有对应的 LLVM 类型信息和作用域信息

### 基本块管理系统

IRBuilder 支持层次化和唯一性的基本块管理：

- **全局唯一基本块**：`bb1`, `bb2`, `bb3`, ...（确保全局唯一性）
- **语义化基本块**：`if.then_1`, `if.else_1`, `loop.head_1`, `loop.body_1`（带语义前缀）
- **嵌套控制流基本块**：`if_1.then_1`, `if_1.else_1`, `if_2.then_1`（嵌套编号）
- **当前基本块上下文**：跟踪当前正在生成指令的基本块
- **基本块跳转**：支持条件和无条件跳转

### 指令生成系统

IRBuilder 提供完整的 LLVM IR 指令生成接口：

- **类型指令**：alloca, store, load, getelementptr
- **算术指令**：add, sub, mul, div, rem
- **比较指令**：icmp
- **逻辑指令**：and, or, xor
- **控制流指令**：br, call, ret
- **位运算指令**：shl, shr
- **内存指令**：memcpy, memset

## 接口设计

### 寄存器管理接口

1. **构造函数**：
   - 接收 ScopeTree 引用作为核心依赖
   - 初始化寄存器计数器和作用域管理结构
   - 设置组件的基本状态

2. **寄存器生成方法**：
   - `newRegister()`: 生成新的临时寄存器，基于当前作用域
   - `newRegister(variableName)`: 为指定变量生成寄存器，考虑作用域层级
   - `newRegister(variableName, suffix)`: 生成带类型区分的寄存器

3. **作用域同步方法**：
   - `syncWithScopeTree()`: 手动同步到当前作用域
   - `getCurrentScope()`: 获取当前作用域引用
   - `cleanupScopeRegisters()`: 清理作用域相关的寄存器

4. **寄存器查询方法**：
   - `getVariableRegister()`: 获取变量对应的寄存器
   - `getSymbolRegister()`: 通过符号获取寄存器
   - `getRegisterType()`/`setRegisterType()`: 获取和设置寄存器类型
   - `getRegisterScope()`: 获取寄存器所属的作用域

5. **作用域检查方法**：
   - `isVariableInCurrentScope()`: 检查变量是否在当前作用域中

### 基本块管理接口

1. **基本块创建方法**：
   - `newBasicBlock(prefix)`: 创建新的基本块，确保全局唯一性
   - `newBasicBlock(prefix, counter)`: 创建带计数器的基本块
   - `newNestedBasicBlock()`: 创建嵌套基本块，带父基本块信息

2. **基本块控制方法**：
   - `setCurrentBasicBlock()`: 设置当前活动的基本块
   - `getCurrentBasicBlock()`: 获取当前基本块
   - `finishCurrentBasicBlock()`: 完成当前基本块的生成

3. **控制流上下文管理**：
   - `enterControlFlowContext()`: 进入新的控制流上下文
   - `exitControlFlowContext()`: 退出当前控制流上下文
   - `getCurrentControlFlowContext()`: 获取当前控制流上下文

4. **基本块验证方法**：
   - `isBasicBlockExists()`: 检查基本块名称是否已存在

### 指令生成接口

1. **基础指令生成**：
   - `emitInstruction()`: 生成原始指令文本
   - `emitComment()`: 生成注释信息

2. **类型相关指令**：
   - `emitAlloca()`: 生成栈分配指令
   - `emitStore()`: 生成存储指令
   - `emitLoad()`: 生成加载指令
   - `emitGetElementPtr()`: 生成指针计算指令

3. **算术运算指令**：
   - `emitAdd()`/`emitSub()`/`emitMul()`/`emitDiv()`/`emitRem()`: 生成基本算术运算

4. **比较和逻辑运算指令**：
   - `emitIcmp()`: 生成整数比较指令
   - `emitAnd()`/`emitOr()`/`emitXor()`: 生成逻辑运算指令

5. **位运算指令**：
   - `emitShl()`/`emitShr()`: 生成位移运算指令

6. **控制流指令**：
   - `emitBr()`/`emitCondBr()`: 生成跳转指令
   - `emitRet()`: 生成返回指令
   - `emitCall()`: 生成函数调用指令

7. **内存操作指令**：
   - `emitMemcpy()`/`emitMemset()`: 生成内存操作指令

## 实现策略

### 输出管理

IRBuilder 直接输出到 stdout，使用以下策略：

1. **立即输出**：每条指令生成后立即输出到 stdout
2. **格式化输出**：确保生成的 IR 符合 LLVM 语法规范
3. **缩进管理**：根据基本块层次自动管理缩进
4. **注释支持**：支持生成调试注释

### 类型系统映射

IRBuilder 维护 Rx 类型到 LLVM 类型的映射：

1. **类型映射方法**：
   - `mapRxTypeToLLVM()`: 将 Rx 类型映射为 LLVM 类型
   - `getPointerElementType()`: 获取指针元素类型
   - `getArrayElementType()`: 获取数组元素类型

2. **类型检查方法**：
   - `isPointerType()`: 检查是否为指针类型
   - `isIntegerType()`: 检查是否为整数类型
   - `getTypeSize()`: 获取类型大小

### 寄存器生命周期管理

IRBuilder 实现复杂的作用域感知的寄存器生命周期管理：

#### 作用域层次结构

1. **ScopeInfo 结构**：
   - 记录作用域层级信息
   - 维护变量名到寄存器的映射关系
   - 管理当前作用域的寄存器集合

2. **作用域栈管理**：
   - 使用向量结构维护作用域栈
   - 跟踪变量名计数器以处理遮蔽
   - 记录当前作用域层级

#### 变量遮蔽处理

1. **变量计数器机制**：
   - 每个变量名维护独立计数器
   - 处理同名变量的遮蔽情况
   - 确保变量名的唯一性

2. **作用域栈策略**：
   - 嵌套作用域的层次化管理
   - 变量查找的优先级策略
   - 作用域退出时的清理机制

3. **命名策略**：
   - 采用"变量名_作用域层级_计数器"格式
   - 确保命名的唯一性和可读性
   - 支持作用域的快速识别

4. **查找策略**：
   - 优先查找当前作用域
   - 逐层向外查找变量
   - 支持跨作用域的变量访问

#### 类型区分处理

1. **指针寄存器**：
   - 使用 `_ptr` 后缀标识指针寄存器
   - 专门用于存储指针值
   - 便于指针操作的识别

2. **值寄存器**：
   - 使用 `_val` 后缀标识值寄存器
   - 专门用于存储实际值
   - 区分指针和值的操作

3. **地址寄存器**：
   - 使用 `_addr` 后缀标识地址寄存器
   - 专门用于存储地址信息
   - 支持地址计算操作

4. **临时寄存器**：
   - 使用 `_tmp` 后缀标识临时寄存器
   - 用于中间计算结果
   - 便于优化和复用

#### 寄存器分配策略

1. **自动分配机制**：
   - 根据作用域和类型自动分配寄存器
   - 确保寄存器名称的唯一性
   - 支持不同类型的寄存器分配

2. **类型跟踪系统**：
   - 记录每个寄存器的类型信息
   - 维护寄存器与作用域的关联
   - 支持类型检查和转换

3. **作用域管理**：
   - 支持嵌套作用域的寄存器管理
   - 作用域退出时的自动清理
   - 跨作用域的寄存器访问控制

4. **寄存器复用优化**：
   - 在安全的情况下复用寄存器
   - 减少寄存器使用数量
   - 提高生成代码的效率

5. **生命周期跟踪**：
   - 跟踪寄存器的创建和销毁
   - 支持寄存器的生命周期分析
   - 便于内存管理和优化

## 错误处理

### 指令验证

IRBuilder 在生成指令前进行验证：

1. **类型检查**：确保操作数类型匹配
2. **寄存器存在性**：确保引用的寄存器已定义
3. **基本块完整性**：确保基本块有正确的终止符
4. **函数签名匹配**：确保函数调用参数匹配

### 错误报告

IRBuilder 提供详细的错误信息：

1. **错误位置**：指出具体的指令位置
2. **错误类型**：说明错误的具体类型
3. **修复建议**：提供可能的修复方案
4. **继续处理**：在非致命错误时继续处理

## 性能优化

### 输出优化

1. **缓冲输出**：使用输出缓冲减少系统调用
2. **批量输出**：将相关指令批量输出
3. **字符串优化**：使用字符串池减少内存分配

### 寄存器优化

1. **寄存器复用**：复用不再使用的寄存器
2. **命名优化**：为频繁使用的寄存器提供有意义的名称
3. **类型缓存**：缓存类型映射结果

## 使用示例

### 基本使用

1. **组件初始化**：
   - 从语义分析阶段获取 ScopeTree
   - 创建 IRBuilder 实例并传入 ScopeTree
   - 设置基本块和作用域上下文

2. **变量分配和操作**：
   - 创建入口基本块并设置为当前基本块
   - 同步到当前作用域
   - 为变量分配指针寄存器并进行存储操作
   - 加载变量值到值寄存器
   - 生成返回指令

3. **寄存器命名策略**：
   - 基于作用域层级生成寄存器名
   - 使用类型后缀区分不同用途的寄存器
   - 确保寄存器名称的唯一性和可读性

### 与 ScopeTree 同步的变量遮蔽处理

1. **作用域结构处理**：
   - 处理多层嵌套的作用域结构
   - 正确识别变量遮蔽情况
   - 维护不同作用域中同名变量的独立性

2. **变量查找策略**：
   - 优先查找当前作用域的变量
   - 支持手动指定作用域查找变量
   - 提供跨作用域的变量访问机制

3. **寄存器命名管理**：
   - 为不同作用域的变量生成不同的寄存器名
   - 通过作用域层级和计数器确保唯一性
   - 支持变量的精确识别和访问

### 基于符号的寄存器管理

1. **符号查找机制**：
   - 通过符号表查找变量信息
   - 基于符号获取对应的寄存器
   - 支持符号信息的完整访问

2. **新符号处理**：
   - 为新创建的符号分配寄存器
   - 将符号信息注册到符号表
   - 建立符号与寄存器的关联关系

3. **符号生命周期管理**：
   - 跟踪符号的创建和销毁
   - 管理符号对应寄存器的生命周期
   - 支持符号作用域的自动清理

### 类型区分处理（基于 Scope）

1. **类型区分寄存器分配**：
   - 为同一变量分配不同类型的寄存器
   - 使用后缀区分指针、值、地址和临时寄存器
   - 确保不同用途寄存器的独立性

2. **寄存器操作策略**：
   - 指针寄存器用于内存分配和地址操作
   - 值寄存器用于存储和加载实际值
   - 地址寄存器用于指针计算和元素访问
   - 临时寄存器用于中间计算结果

3. **作用域清理机制**：
   - 作用域退出时自动清理相关寄存器
   - 防止寄存器名称冲突和内存泄漏
   - 维护寄存器管理的正确性

### 函数调用

1. **内置函数调用**：
   - 生成内置函数的调用指令
   - 处理内置函数的特殊参数和返回值
   - 确保内置函数调用的正确性

2. **用户函数调用**：
   - 生成用户定义函数的调用指令
   - 处理函数参数的传递和返回值的接收
   - 维护函数调用的类型安全

### 控制流

1. **条件分支处理**：
   - 创建条件控制流上下文
   - 生成条件比较和跳转指令
   - 管理分支基本块的创建和连接

2. **基本块管理**：
   - 创建嵌套基本块并处理命名冲突
   - 管理基本块的作用域和生命周期
   - 确保控制流的正确连接

3. **作用域同步**：
   - 在基本块切换时同步作用域
   - 处理基本块作用域的进入和退出
   - 维护变量和寄存器的正确关联

### 循环处理

1. **循环结构生成**：
   - 创建循环控制流上下文
   - 生成循环头、体和结束基本块
   - 处理循环条件和跳转逻辑

2. **循环体管理**：
   - 为循环体创建独立作用域
   - 处理循环体内的变量和寄存器
   - 确保循环体的正确执行

3. **循环控制流**：
   - 生成循环头到循环体的跳转
   - 处理循环体到循环头的回跳
   - 管理循环退出条件

## 与其他组件的集成

### 与 TypeMapper 的集成

1. **类型转换支持**：
   - 依赖 TypeMapper 进行 Rx 类型到 LLVM 类型的转换
   - 确保类型映射的正确性和一致性
   - 支持复杂类型的处理和转换

2. **类型检查机制**：
   - 在指令生成前进行类型检查
   - 确保操作数类型的匹配
   - 提供类型错误的详细信息

### 与 FunctionGenerator 的集成

1. **函数体生成**：
   - 为 FunctionGenerator 提供指令生成接口
   - 支持函数体的完整生成
   - 处理函数内的控制流和变量管理

2. **函数上下文管理**：
   - 维护函数生成的基本块和作用域
   - 支持函数参数和返回值的处理
   - 确保函数结构的正确性

### 与 ExpressionGenerator 的集成

1. **表达式代码生成**：
   - 为 ExpressionGenerator 提供表达式生成支持
   - 处理复杂表达式的指令序列
   - 管理表达式计算中的临时寄存器

2. **表达式类型处理**：
   - 确保表达式结果的类型正确性
   - 处理表达式中的类型转换
   - 支持表达式值的存储和使用

## 测试策略

### 单元测试

1. **寄存器管理测试**：验证寄存器分配和类型跟踪
2. **基本块管理测试**：验证基本块创建和跳转
3. **指令生成测试**：验证各种指令的正确生成
4. **错误处理测试**：验证错误检测和报告

### 集成测试

1. **函数生成测试**：验证完整函数的生成
2. **控制流测试**：验证复杂控制流的生成
3. **类型系统测试**：验证类型映射的正确性
4. **输出验证测试**：验证输出 IR 的语法正确性

## 总结

IRBuilder 是 IR 生成模块的核心组件，提供了完整的 LLVM IR 文本生成功能。通过自定义的指令生成系统，IRBuilder 能够在不依赖 LLVM C++ API 的情况下生成符合 LLVM 15 规范的 IR 文本。

IRBuilder 的设计充分考虑了类型安全、寄存器管理、基本块管理和错误处理等关键方面，为其他 IR 生成组件提供了坚实的基础。通过与 TypeMapper、FunctionGenerator 和 ExpressionGenerator 等组件的紧密集成，IRBuilder 能够支持完整的 Rx 语言到 LLVM IR 的转换。