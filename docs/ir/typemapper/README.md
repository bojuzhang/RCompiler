# TypeMapper 组件设计文档

## 概述

TypeMapper 组件负责将 Rx 语言的类型系统映射到 LLVM IR 类型系统。它是 IR 生成阶段的核心组件，确保类型信息的正确转换和兼容性检查。

## 设计目标

1. **完整的类型映射**：支持所有 Rx 语言类型到 LLVM 类型的映射
2. **类型安全映射**：确保类型转换的正确性和安全性
3. **语义集成**：与语义分析阶段的类型信息完全集成
4. **性能优化**：避免重复的类型映射计算

## 核心架构

### 类型映射表

TypeMapper 维护一个从 Rx 类型到 LLVM 类型的映射表，针对 32 位机器进行优化：

1. **基础类型映射**：
   - 整数类型：i32 → i32, u32 → u32
   - 平台相关类型：isize → i32（32位机器）, usize → u32（32位机器）
   - 布尔类型：bool → i1
   - 字符串类型：str → i8*
   - 字符类型：char → i8
   - 单元类型：() → void

2. **SemanticType 特殊类型映射**：
   - Int 类型 → i32
   - SignedInt 类型 → i32
   - UnsignedInt 类型 → u32

3. **复合类型映射策略**：
   - 数组类型：`[T; N]` 映射为 `[N x T]`
   - 引用类型：`&T`, `&mut T` 映射为 `T*`
   - 函数类型：`fn(A, B) -> C` 映射为 `C (A, B)*`
   - 结构体类型：映射为 `%struct_Name`（避免C++转义问题）

### 类型缓存机制

1. **核心数据结构**：
   - ScopeTree 引用用于符号查找
   - 类型缓存映射表避免重复计算
   - 多级缓存提高查找效率

2. **核心映射接口**：
   - `mapRxTypeToLLVM()`: 将 Rx 类型字符串映射为 LLVM 类型
   - `mapSemanticTypeToLLVM()`: 将语义类型对象映射为 LLVM 类型

3. **复合类型映射接口**：
   - `mapArrayTypeToLLVM()`: 处理数组类型的映射
   - `mapReferenceTypeToLLVM()`: 处理引用类型的映射
   - `mapFunctionTypeToLLVM()`: 处理函数类型的映射
   - `mapStructTypeToLLVM()`: 处理结构体类型的映射

4. **类型信息查询接口**：
   - `getElementType()`: 获取复合类型的元素类型
   - `areTypesCompatible()`: 检查类型兼容性
   - `getCommonType()`: 计算两个类型的公共类型

5. **类型属性接口**：
   - `getTypeSize()`: 获取类型的字节大小
   - `getTypeAlignment()`: 获取类型的对齐要求

## 实现策略

### 基础类型映射

1. **缓存优先策略**：
   - 首先检查类型缓存，避免重复计算
   - 如果缓存命中，直接返回缓存结果
   - 将新计算的结果存入缓存

2. **特殊类型处理**：
   - 优先处理 SemanticType 特殊类型映射
   - 检查是否为 Int、SignedInt、UnsignedInt 等特殊类型
   - 使用预定义的映射表进行转换

3. **基础类型查找**：
   - 在基础类型映射表中查找直接匹配
   - 处理常见的整数、布尔、字符串等类型
   - 确保基础类型的快速映射

4. **复合类型识别**：
   - 通过字符串前缀识别数组类型 `[T; N]`
   - 通过前缀识别引用类型 `&T`, `&mut T`
   - 通过前缀识别函数类型 `fn(...)`
   - 将其他类型作为自定义类型处理

5. **结果缓存**：
   - 将计算结果存入类型缓存
   - 确保后续相同类型的快速查找
   - 维护缓存的一致性

### SemanticType 映射

1. **空值处理**：
   - 检查语义类型指针的有效性
   - 为空指针提供安全的默认类型
   - 使用 `i8*` 作为通用默认类型

2. **类型字符串化**：
   - 将语义类型转换为字符串表示
   - 用于缓存键值的生成
   - 支持类型的一致性比较

3. **动态类型识别**：
   - 使用动态类型转换识别具体语义类型
   - 处理 IntType、SignedIntType、UnsignedIntType
   - 为每种特殊类型提供精确的映射

4. **复合类型委托**：
   - 将数组类型委托给专门的数组映射方法
   - 将引用类型委托给引用映射方法
   - 将函数类型委托给函数映射方法

5. **简单类型回退**：
   - 对于无法识别的复合类型，回退到字符串映射
   - 确保类型映射的完整性
   - 提供统一的映射接口

### 数组类型映射

1. **递归元素映射**：
   - 递归调用映射函数处理元素类型
   - 确保嵌套类型的正确处理
   - 维护类型映射的一致性

2. **大小信息提取**：
   - 从大小表达式中提取数组大小
   - 处理字面量大小值
   - 为无法确定的大小提供默认值

3. **LLVM 数组类型构造**：
   - 按照 LLVM 语法构造数组类型字符串
   - 使用 `[N x T]` 格式表示数组
   - 确保类型字符串的正确性

### 引用类型映射

1. **目标类型映射**：
   - 递归映射引用的目标类型
   - 处理复杂的嵌套引用情况
   - 确保目标类型的正确转换

2. **指针类型生成**：
   - 在目标类型后添加 `*` 表示指针
   - 统一处理可变和不可变引用
   - 符合 LLVM 的指针类型表示

### 结构体类型映射

1. **符号查找**：
   - 在作用域树中查找结构体符号
   - 验证符号的类型和有效性
   - 处理未找到符号的情况

2. **类型名称构造**：
   - 使用 `%struct_` 前缀构造结构体类型
   - 避免 C++ 关键字冲突问题
   - 确保类型名称的唯一性

3. **错误处理**：
   - 为未知结构体提供安全的默认类型
   - 使用 `i8*` 作为通用指针类型
   - 保持类型系统的安全性

### 多层嵌套类型处理

1. **递归解析策略**：
   - 使用循环结构处理多层嵌套
   - 逐步解析外层类型到内层类型
   - 维护解析状态的一致性

2. **数组嵌套处理**：
   - 识别数组类型的开始和结束位置
   - 提取内层类型和大小信息
   - 递归处理内层类型的映射

3. **引用嵌套处理**：
   - 处理可变引用 `&mut T` 的特殊情况
   - 逐步剥离引用符号
   - 继续处理内层类型

4. **基础类型识别**：
   - 在解析完成后识别基础类型
   - 使用映射表进行最终转换
   - 处理自定义结构体类型

### 多层嵌套数组处理

1. **递归数组检测**：
   - 检查数组元素是否也是数组类型
   - 识别多维数组的结构
   - 递归处理内层数组类型

2. **多维数组构造**：
   - 按照维度顺序构造 LLVM 数组类型
   - 使用嵌套的 `[N x [M x T]]` 格式
   - 确保维度信息的正确性

3. **大小信息处理**：
   - 提取每个维度的大小信息
   - 处理字面量大小表达式
   - 为缺失大小提供默认值

### 多层嵌套引用处理

1. **引用层次检测**：
   - 检查引用目标是否也是引用类型
   - 识别多层引用的结构
   - 处理 `&&T` 等复杂引用

2. **递归引用映射**：
   - 递归处理内层引用类型
   - 逐层添加指针符号
   - 构造正确的多级指针类型

3. **单层引用处理**：
   - 为简单引用生成单级指针
   - 使用 `T*` 格式表示引用
   - 确保指针类型的正确性

## 类型兼容性检查

### 兼容性规则

1. **完全相同检查**：
   - 首先检查两个类型是否完全相同
   - 相同类型直接返回兼容
   - 提供最快的兼容性判断

2. **指针类型兼容性**：
   - 检查两个类型是否都是指针类型
   - 递归检查指针基类型的兼容性
   - 忽略指针层级的差异

3. **数组类型兼容性**：
   - 检查两个类型是否都是数组类型
   - 递归检查数组元素类型的兼容性
   - 忽略数组大小的差异

4. **整数类型兼容性**：
   - 检查两个类型是否都是整数类型
   - 在 32 位机器上支持整数类型的隐式转换
   - 利用 LLVM 的类型转换能力

5. **默认不兼容**：
   - 对于不匹配的类型组合返回不兼容
   - 确保类型系统的安全性
   - 防止错误的类型转换

### 公共类型计算

1. **相同类型优化**：
   - 如果两个类型相同，直接返回该类型
   - 避免不必要的计算
   - 提高性能

2. **整数类型公共类型**：
   - 在 32 位机器上，整数类型的公共类型为 i32
   - 符合大多数操作的默认类型选择
   - 确保整数运算的一致性

3. **指针类型公共类型**：
   - 递归计算指针基类型的公共类型
   - 在公共基类型后添加指针符号
   - 保持指针层级的一致性

4. **默认策略**：
   - 对于无法计算公共类型的情况，返回第一个类型
   - 提供安全的默认行为
   - 保持类型系统的稳定性

## 类型大小和对齐信息

1. **大小映射表**：
   - 维护基础类型到字节大小的映射
   - 针对 32 位机器进行优化
   - 包含常见 LLVM 类型的大小信息

2. **默认大小处理**：
   - 为未知类型提供默认大小（4字节）
   - 适应 32 位机器的内存布局
   - 确保大小信息的完整性

3. **对齐计算**：
   - 大多数类型的对齐要求与大小相同
   - 简化对齐计算逻辑
   - 提供一致的对齐策略

## 与其他组件的集成

### 与 IRBuilder 的集成

1. **组件初始化**：
   - IRBuilder 创建并持有 TypeMapper 实例
   - 传入 ScopeTree 作为共享依赖
   - 建立组件间的紧密集成

2. **指令生成集成**：
   - 在 alloca 指令生成中使用类型映射
   - 在 load 指令生成中使用类型信息
   - 确保生成指令的类型正确性

3. **类型转换支持**：
   - 为 IRBuilder 提供类型转换接口
   - 支持各种类型间的转换操作
   - 维护类型转换的安全性

### 与 ExpressionGenerator 的集成

1. **二进制操作支持**：
   - 为表达式生成提供类型映射服务
   - 确保二进制操作的类型一致性
   - 生成正确的 LLVM 指令

2. **表达式类型处理**：
   - 处理表达式结果类型的映射
   - 支持复杂表达式的类型计算
   - 维护表达式类型系统的正确性

## 错误处理

### 类型映射错误

1. **未知类型处理**：
   - 记录未知类型的警告信息
   - 提供安全的默认类型（i8*）
   - 确保编译过程的继续进行

2. **错误日志记录**：
   - 将错误信息输出到标准错误流
   - 包含详细的错误上下文
   - 便于问题诊断和调试

### 类型不匹配错误

1. **不匹配检测**：
   - 检测期望类型与实际类型的不匹配
   - 提供详细的类型信息
   - 帮助开发者定位问题

2. **错误报告**：
   - 格式化错误信息为可读格式
   - 包含期望类型和实际类型
   - 提供清晰的错误描述

## 性能优化

### 类型缓存策略

1. **多级缓存设计**：
   - 为不同类型的映射使用独立的缓存
   - 基础类型、数组类型、引用类型分别缓存
   - 提高缓存命中率

2. **智能缓存选择**：
   - 根据类型特征选择合适的缓存
   - 减少缓存查找的时间复杂度
   - 优化缓存使用效率

3. **语义类型缓存**：
   - 为语义类型对象提供专门缓存
   - 使用类型字符串作为缓存键
   - 避免重复的语义类型分析

### 内存池优化

1. **字符串池机制**：
   - 使用字符串池减少内存分配
   - 重用相同的字符串对象
   - 降低内存使用和碎片化

2. **字符串内化**：
   - 将常用字符串内化到池中
   - 返回字符串的指针而非副本
   - 提高字符串比较效率

## 测试策略

### 单元测试

1. **基础类型映射测试**：
   - 验证基础类型的正确映射
   - 测试 32 位机器的特殊类型映射
   - 确保平台相关类型的正确性

2. **SemanticType 映射测试**：
   - 测试各种语义类型的映射
   - 验证特殊语义类型的处理
   - 确保语义类型系统的正确性

3. **复合类型映射测试**：
   - 测试数组类型的映射
   - 测试引用类型的映射
   - 验证复合类型的构造规则

4. **嵌套类型测试**：
   - 测试多层嵌套类型的处理
   - 验证复杂嵌套结构的正确性
   - 确保递归映射的正确性

5. **多维数组测试**：
   - 测试多维数组类型的映射
   - 验证维度信息的正确处理
   - 确保数组类型的正确构造

### 集成测试

1. **IRBuilder 集成测试**：
   - 测试类型映射在 IR 生成中的使用
   - 验证生成指令的类型正确性
   - 确保组件集成的稳定性

## 使用示例

### 基本使用

1. **组件初始化**：
   - 从语义分析器获取作用域树
   - 创建 TypeMapper 实例
   - 准备进行类型映射

2. **基础类型映射**：
   - 映射整数类型（i32, u32）
   - 映射平台相关类型（isize, usize）
   - 映射布尔和字符串类型

3. **复合类型映射**：
   - 映射数组类型
   - 映射引用类型
   - 验证复合类型的正确构造

### 高级使用

1. **语义类型映射**：
   - 从符号获取语义类型
   - 进行语义类型到 LLVM 类型的映射
   - 处理特殊语义类型

2. **类型兼容性检查**：
   - 检查两个类型的兼容性
   - 计算类型的公共类型
   - 进行类型系统的验证

3. **类型信息查询**：
   - 获取类型的字节大小
   - 获取类型的对齐要求
   - 进行内存布局分析

### 多层嵌套类型示例

1. **多维数组处理**：
   - 处理二维数组类型
   - 验证维度信息的正确性
   - 生成正确的 LLVM 数组类型

2. **多层引用处理**：
   - 处理多级指针类型
   - 验证引用层级的正确性
   - 生成正确的指针类型

3. **复杂嵌套结构**：
   - 处理数组和引用的复杂嵌套
   - 验证嵌套结构的正确解析
   - 生成正确的复合类型

## 总结

TypeMapper 组件是 IR 生成阶段的核心组件，提供了完整的类型映射功能：

1. **完整的类型支持**：支持所有 Rx 语言类型到 LLVM 类型的映射，包括特殊SemanticType
2. **32位机器优化**：正确处理isize/usize在32位机器上的映射
3. **嵌套类型处理**：正确处理多层嵌套的数组和引用类型
4. **类型安全**：提供类型兼容性检查和公共类型计算
5. **性能优化**：通过缓存和内存池优化性能
6. **易于集成**：与 IRBuilder 和 ExpressionGenerator 等组件无缝集成
7. **C++兼容**：避免结构体类型名的转义问题

通过 TypeMapper，IR 生成器可以正确地处理各种复杂的类型场景，确保生成的 LLVM IR 的类型正确性和安全性。